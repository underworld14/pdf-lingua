import { NextRequest, NextResponse } from "next/server";
import path from "path";
import fs from "fs";
import { JobService } from "@/lib/services/jobService";

export async function GET(
  request: NextRequest,
  { params }: { params: { jobId: string; type: string; filename: string } }
) {
  // Ensure params are properly awaited in Next.js App Router
  const { jobId, type, filename } = params;
  
  // Initialize job service
  const jobService = new JobService();
  
  // Check if job exists
  const job = await jobService.getJob(jobId);
  if (!job) {
    return NextResponse.json(
      { error: "Job not found" },
      { status: 404 }
    );
  }
  
  // Validate the type
  if (type !== "original" && type !== "translated") {
    return NextResponse.json(
      { error: "Invalid file type" },
      { status: 400 }
    );
  }
  
  // Get file path
  let filePath;
  if (type === "original") {
    // Find the original file by name from the job's files
    const decodedFilename = decodeURIComponent(filename);
    
    // Find the file with the matching name
    const matchingFile = job.files.find(f => f.originalName === decodedFilename);
    if (!matchingFile) {
      return NextResponse.json(
        { error: "File not found" },
        { status: 404 }
      );
    }
    
    filePath = matchingFile.originalPath;
  } else {
    // For translated files, we'll serve from a translations directory
    // In a real app, these would be generated by the PDF service
    const decodedFilename = decodeURIComponent(filename);
    filePath = path.join(process.cwd(), "uploads", jobId, "translated", decodedFilename);
    
    // Check if file exists - if not, generate a dummy translated file for demo
    if (!fs.existsSync(filePath)) {
      const originalName = decodedFilename.replace("translated_", "");
      const originalFile = path.join(process.cwd(), "uploads", jobId, originalName);
      
      // Create translations directory if it doesn't exist
      const translationsDir = path.join(process.cwd(), "uploads", jobId, "translated");
      if (!fs.existsSync(translationsDir)) {
        fs.mkdirSync(translationsDir, { recursive: true });
      }
      
      // In a real app, this would actually call the Lumina PDF API to generate the translated PDF
      // For demo purposes, we're just copying the original file
      if (fs.existsSync(originalFile)) {
        fs.copyFileSync(originalFile, filePath);
      } else {
        return NextResponse.json(
          { error: "Original file not found" },
          { status: 404 }
        );
      }
    }
  }
  
  try {
    // Check if file exists
    const fileExists = fs.existsSync(filePath);
    if (!fileExists) {
      return NextResponse.json(
        { error: "File not found" },
        { status: 404 }
      );
    }
    
    // Read the file
    const fileBuffer = fs.readFileSync(filePath);
    
    // Return the file
    return new NextResponse(fileBuffer, {
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": `attachment; filename="${encodeURIComponent(filename)}"`,
      },
    });
  } catch (error) {
    console.error("Error serving file:", error);
    return NextResponse.json(
      { error: "Failed to serve file" },
      { status: 500 }
    );
  }
}
